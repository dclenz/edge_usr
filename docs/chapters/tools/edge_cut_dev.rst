EDGEcut Developer Guide
========================

This is the developer guide for EDGEcut.  The goal of this document is to
describe some of the more intricate details of EDGEcut, extra documentation for
CGAL routines, potential pitfalls, and anything else that didn't fit in the user
guide.

This guide should **not** be considered exhaustive by any means.

For more general usage and building instructions, check out the
`EDGEcut User Guide <https://edge-usr.readthedocs.io/en/develop/chapters/tools/edge_cut.html>`_.

.. contents::
  :depth: 3

Overview
----------
The purpose of EDGEcut is to generate 3D surface meshes for regions bounded on
one side by a topographical profile. These surface meshes can be used in
conjunction with another meshing tool (such as gmsh) in order to create a 3D
tetrahedral mesh for use in EDGE.

EDGEcut has been designed to provide the following functionality, features 5
and 6 are not yet implemented.

  1. Create a surface mesh representing a topographical surface.
  2. Create a separate surface mesh which, together with the topography mesh, forms a
     closed conformal mesh bounding a rectilinear region below the Earth's
     surface.
  3. Allow the size and quality of the mesh facets to be set by the user at
     run-time.
  4. Allow the size and quality of the mesh facets to vary
     throughout the domain in a user-controlled way.
  5. Allow the user to specify the shape of the "underground" region to be any
     (reasonable) shape.
  6. Allow the user to specify a model of a seismic fault, and
     create a new surface mesh which:

      * Approximates well the original fault model
      * Is conformal with respect to the topography mesh and boundary mesh
      * Is contained entirely with the volume bounded by the topography and
        boundary meshes
      * Has its facet size and quality determined by the user at run-time


.. NOTE::
  We define a "3D surface mesh" to be a collection of triangles with vertices
  in 3-space such that the triangles only intersect on edges or vertices.
  Mathematically, we mean a pure simplicial 2-complex embedded in R^3. As such,
  a surface mesh is a 2-dimensional piece-wise linear surface in R^3.  A surface
  mesh is not necessarily a manifold surface and may or may not bound a volume.

  In this guide a 3D surface mesh will often be referred to as a "surface mesh"
  or just a "mesh." If any other type of mesh is discussed, it will be clear
  from the context.

Program Logic
--------------
The program logic of EDGEcut can be broken into several distinct tasks


Mesher
---------
EDGEcut uses the meshing algorithm in the `CGAL Mesh_3 Package <https://doc.cgal.org/latest/Mesh_3/index.html>`_.
The mesher takes two arguments, a **domain** and a set of **criteria**.

.. NOTE::
  CGAL provides a specialized surface meshing package called
  `3D Surface Mesh Generation <https://doc.cgal.org/latest/Surface_mesher/index.html>`_.
  However, it appears that the functionality of this package is being merged into
  Mesh_3 and that little to no future development is planned for this package:
  `see here <https://github.com/CGAL/cgal/issues/3237>`_ for more info.

Mesh Domain
^^^^^^^^^^^^
Roughly speaking, a `mesh domain <https://doc.cgal.org/latest/Mesh_3/classMeshDomain__3.html>`_
in CGAL is comprised of two things: a representation of a geometric object, and
an optional list of "features". A feature is a point or line segment which is
somehow important to the overall geometry of the domain. Any features in the
mesh domain are guaranteed to be present in any approximation generated by the
mesher.

A CGAL mesh domain is initially constructed from a suitable geometric object.
Then, if desired, the new mesh domain can add a list of features to itself.

The geometric object intrinsic to a mesh domain can be represented in several
ways. EDGEcut represents them as `polyhedral surfaces <https://doc.cgal.org/latest/Polyhedron/index.html>`_;
specifically, with the class `Mesh_polyhedron_3 <https://doc.cgal.org/latest/Mesh_3/classCGAL_1_1Polyhedral__mesh__domain__3.html>`_.
CGAL also provides the class `Polyhedron_3 <https://doc.cgal.org/latest/Polyhedron/classCGAL_1_1Polyhedron__3.html>`_
which is the generic implementation of a polyhedral surface - however, the class
Mesh_Polyhedron_3 is a customized implementation of the "polyhedral surface" concept,
designed to interface with the mesher, which is why we use it in EDGEcut.

Typically, when the mesher encounters a polyhedral surface, it expects a domain consisting of a closed
polyhedral surface as well as a non-closed polyhedral surface which exists inside
the volume bounded by the closed surface. It then proceeds to generate a 3D *volume*
mesh of tetrahedra which fills the entire bounded volume. EDGEcut does not do
volume mesh generation, so we use a different approach.

To force the mesher to do only surface meshing, our domain is constructed from a vector
of non-closed polyhedral surfaces. In our case, we only have one surface to mesh,
so we pass a vector with one polyhedral surface. `This example <https://doc.cgal.org/latest/Mesh_3/Mesh_3_2remesh_polyhedral_surface_8cpp-example.html>`_
shows how to do this in practice.

A "1-dimensional feature" for a CGAL mesh domain is a sequence of connected line segments;
that is, an ordered collection of line segments where the end point of one segment is
the starting point of the next segment. CGAL gives a name to such a sequence of connected
line segments: they call them **polylines**. We will use the same terminology in this guide.

EDGEcut represents a polyline as a vector of points, where each pair of consecutive
points defines a line segment in the polyline. A collection of polylines is typically
represented as a list of vectors; see this `sample code <https://doc.cgal.org/latest/Mesh_3/Mesh_3_2mesh_two_implicit_spheres_with_balls_8cpp-example.html>`_
for and example.

.. WARNING::
  If a collection of polylines is added to a mesh domain, then the *polylines may only
  intersect at their endpoints*. This means that two coplanar line segments cannot
  cross each other. It also means that two polylines can't share a vertex, UNLESS that
  vertex is an endpoint of both polylines. We re-emphasize this point: two polylines
  cannot intersect at a shared vertex if that vertex is in the middle of at least one
  of the polylines.

  Similarly, it is required that all polylines do not intersect themselves.

  If these conditions are not met, the mesher will hang and/or crash with no warning.

Mesh Criteria
^^^^^^^^^^^^^^
Edge Size
  Max distance between protecting balls in 1D feature preservation

Facet Size
  Radius of Surface Delaunay ball

Facet Distance
  Max distance between center for Surface Delaunay Ball and circumcenter of triangle face (surface approximation parameter)

Facet Angle
  Max angle of a surface triangle face [ MUST BE <= 30 ]

Cell Size
  Tetrahedral circumradius

Cell Radius\/Edge Ratio
  Max ratio of circumradius to shortest edge (mesh quality parameter) [ MUST BE >= 2 ]


Mesh Optimization
^^^^^^^^^^^^^^^^^^^
NOTE the mesher cannot detect and remove "slivers" - optimizers must be
used to remove them and improve mesh quality

NOTE A "Surface Delaunay Ball" is the 3D ball circumscribing a triangle surface facet which also
has its center on the theoretical surface to be meshed. The center of the Surface
Delaunay Ball will not coincide with the triangle circumcenter when the surface mesh
is a poor approximation to the theoretical surface


Mesher Debug Flags
^^^^^^^^^^^^^^^^^^^^^
There are several flags that CGAL provides for debugging the mesher. Three of
these are described in this section: the ``CGAL_MESH_3_VERBOSE``, ``CGAL_MESH_3_PROFILING``,
and ``CGAL_MESH_3_PROTECTION_DEBUG`` flags.

These flags (and others) do not seem to be readily documented in the CGAL user or
reference manuals. One good way to see how they are used is to simply search the
`CGAL code repository <https://github.com/CGAL/cgal>`_ for each flag.

.. NOTE::
  The flags ``CGAL_MESH_3_VERBOSE`` and ``CGAL_MESH_3_PROFILING`` are boolean flags -
  that is, they are either defined or not. ``CGAL_MESH_3_PROTECTION_DEBUG`` should
  take on integer values - values of 1, 2, and 4 are tested against in the CGAL
  source code.

A general description of the these debug flags is given below:

CGAL_MESH_3_VERBOSE
  Shows the progress of the meshing routine. Displays the number facets and/or
  cells left to refine, as well as the rate at which the meshing algorithm is
  running (reported in vertices/second). Also prints some statistics regarding
  the geometric quality of the mesh facets and cells.

CGAL_MESH_3_PROFILING
  Prints basic statistics about the meshing process, mainly the size of various
  mesh parameters and the time elapsed in each stage of the algorithm.

CGAL_MESH_3_PROTECTION_DEBUG
  Reports on the process of features preservation, which happens before the main
  meshing routine begins. The output is often not very helpful, but if the feature
  preservation routine is crashing, it may be helpful to pinpoint where the problem is.

  The feature preservation routine can fail for a variety of reasons, but the most
  common is that two polyline features intersect each other, and the intersection
  point is not an endpoint of both polylines (this scenario is not allowed by the mesher,
  but is not checked for ahead of time). When this happens, checking the debug output
  for the most recently processed points can give hints as to where in the mesh
  there may be ill-defined features.

  Also, note that this produces a large amount of output. You may want to redirect
  your output to a file when running with this flag.


EDGEcut enables ``CGAL_MESH_3_VERBOSE`` and ``CGAL_MESH_3_PROFILING`` flags when
the debug mode is built. As a reminder, the debug version of EDGEcut can be built with

.. code-block:: bash

  scons mode=debug
  scons mode=debug+san
  scons mode=debug+cov


**Other Debug Flags**

| There are many other debug flags in CGAL; what exactly they do has not been examined,
  but they may be useful:
| CGAL_MESH_3_IO_VERBOSE
| CGAL_MESH_3_VERY_VERBOSE
| CGAL_MESH_3_EXPORT_PERFORMANCE_DATA
| CGAL_CONCURRENT_MESH_3_PROFILING
| CGAL_MESH_3_EXUDER_VERBOSE        (set by CGAL_MESH_3_VERBOSE)
| CGAL_MESH_3_PERTURBER_VERBOSE     (set by CGAL_MESH_3_VERBOSE)


Memory Debugging
-------------------
Due to the way in which CGAL rounds floating point arithmetic, `Valgrind cannot be used <https://github.com/CGAL/cgal/issues/3094#issuecomment-389785782>`_.
To debug memory management errors, the `Clang Address Sanitizer <https://clang.llvm.org/docs/AddressSanitizer.html>`_
is recommended.  To use the address sanitizer, simply compile with clang and add the
-fsanitize=address and -fno-omit-frame-pointer (the second flag is optional, but recommended for
nicer stacktraces).

.. NOTE::
  The address sanitizer are enabled by default when compiling in debug mode.

Memory Profiling
------------------
In order to measure the memory usage of EDGEcut, the `Heap Profiler <https://gperftools.github.io/gperftools/heapprofile.html>`_
from gperftools (Google Performance Tools) may be used. The heap profiler takes periodic
snapshots of the heap and tracks how memory is being used by different sub-processes.
This information is summarized in .heap files and can be visualized by the ``pprof``
utility.

The following sections give a brief overview for getting started with the heap profiler;
please see the `Heap Profiler Documentation <https://gperftools.github.io/gperftools/heapprofile.html>`_
for more information.


GPerfTools Installation
^^^^^^^^^^^^^^^^^^^^^^^^
To use the heap profiler, GPerfTools must first be installed: see their
`installation instructions <https://github.com/gperftools/gperftools/blob/master/INSTALL>`_
for more information. However, a potential bug for x86-64 systems is mentioned here. According
to the INSTALL document in the GPerfTools repo, a deadlock can occur during stack unwinding
in certain circumstances. To avoid this, two workarounds are described:

  1. Download `libunwind version 0.99 <http://download.savannah.gnu.org/releases/libunwind/libunwind-0.99-beta.tar.gz>`_
     before configuring or making GPerfTools. However, there are still reports of crashes with
     this library; the GPerfTools installation instructions has more info.

  2. Make sure that all applications using GPerfTools (i.e. EDGEcut) are built with
     the flag -fno-omit-frame-pointer AND configure GPerfTools with the option
     --enable-frame-pointers.

EDGEcut has been tested with GPerfTools using option 2 above. If you run into issues, make
sure to check out the GPerfTools README, as well.

The actual installation of GPerfTools is standard, simply get the source code and run:

.. code-block:: bash

  ./configure              # add --enable-frame-pointers if using option (2) above
  make
  make check
  make install

GPerfTools Usage
^^^^^^^^^^^^^^^^^^
Firstly, EDGEcut must be linked with -ltcmalloc in order to use the heap profiler;
the ``tcmalloc`` library is installed with GPerfTools.

Next, the environment variable ``HEAPPROFILE`` must be set to a descriptive string.
This variable both turns on the heap profiler and sets the prefix for file output. For instance,
if ``HEAPPROFILE=EDGEcut-test``, then the profiler will write heap summaries as

.. code-block:: bash

  EDGEcut-test.0000.heap
  EDGEcut-test.0001.heap
  EDGEcut-test.0002.heap
  ...

In the EDGEcut source code, a few additions must be made. First, the header file
``<gperftools/heap-profiler.h>`` must be included in main.cpp. Next, HeapProfilerStart() must be called
to begin tracking the heap. HeapProfilerStart() takes a string argument which is used to
title some of the graphs, but has little usage otherwise. A call to HeapProfilerStop()
(which takes no arguments) must be made to stop tracking the heap. Finally, adding
calls to HeapProfilerDump() throughout the EDGEcut source will force the profiler to
snapshot the heap at that point in the program's execution.

There are optional environment variables that can be set which control how often
heap usage is measured. These variables are described in the "Modifying Runtime Behavior"
section of the `Heap Profiler Documentation <https://gperftools.github.io/gperftools/heapprofile.html>`_.

To analyze a .heap file, we use the ``pprof`` tool. This tools is highly customizable, so
we refer the reader to the `pprof manual <https://github.com/google/pprof/blob/master/doc/README.md>`_, since
different users will most likely seek something different from the tool. Some basic invocations
are listed below.

In all examples below, EDGEcut-test.000n.heap is one of the .heap profiles written during program execution, and
./edge_cut is the binary which generated these files.

To generate a text summary of the heap:

.. code-block:: bash

  pprof --text ./edge_cut ./EDGEcut-test.000n.heap > output.txt

To create a graph of memory usage, separated by subprocess and ordered by parent/child
processes:

.. code-block:: bash

  pprof --svg ./edge_cut ./EDGEcut-test.000n.heap > output.svg

Graphs can saved in different formats, with the --dot, --png, --jpg, --gif, and --pdf flags. To view a
temporary graph in a web browser, use --web; to view with Ghostview, use --gv.
The `Heap Profiler Documentation <https://gperftools.github.io/gperftools/heapprofile.html>`_
details how to understand this graph representation, as well.

To diff two heap reports and only report the change in heap usage between the two, use

.. code-block:: bash

  pprof --web --base=./EDGEcut-test.000k.heap ./edge_cut ./EDGEcut-test.000n.heap

Of course, profiles can be diffed using any output format (--text, --svg, etc).

ETC ( don't forget to add )
------------------------------
there is a tag that can be passed to mesher to ensure manifold

lloyd and odt are global optimizers so don't preserve manifold-ness

memory usage statistics

memory profiling directions

Finish mesh optimization section

Finish Program logic section
